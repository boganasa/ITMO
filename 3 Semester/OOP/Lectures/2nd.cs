/*                                ### Три основных принципа (механизма) ООП ###
Инкапсуляция - (в оболочке) - принцип, согласно которому любой класс, и в более широком смысле - 
любая часть системы, должны рассматриваться как черный ящик: пользователь класса или подсистемы должен
видеть только интерфейс (то есть список декларируемых свойств и методов) и не вникать во внутреннюю реализацию.
Инкапсуляция позволяет минимизировать число связей между классами

Наследование - возможность порождать один класс от другого с сохранением всех свойств и методов
класса-предка(суперкласса), добавляя при необходимости новые свойства и методы. Наследование - очень 
сильная связь между двумя классами. Помогает переиспользовать код и неразрывно связано с понятием полиморфизма.

interface - это языковая конструкция, похожая с точки зрения синтаксиса на class, но фундаментально отличающаяся 
от него. Интерфейс можно сравнить с абстрактным классом, у которого только абстрактный метод, то есть нет никакой 
его реализации. У него есть функция множественного наследования (когда один класс наследуется сразу от нескольких).
Название должно начинаться с буквы I
Можно реализовать смвойства методы и события
Не нужно добавлять реализацию членов
Интерфейс можно наследовать от многих интерфейсов
Класс можно наследовать от одного класса и от многих интерфейсов
*/
namespace Lec2_Inheritance
{
    public interface IMortal
    {
        bool IsAlive {get; } //Одно свойство с обязательной реализацией публичного метода
    }
}

namespace Lec2_Inheritance
{
    public interface ICanStop
    {
        bool Stop();
    }
}

namespace Lec2_Inheritance
{
    public interface ICanFly : ICanStop
    {
        bool IsFlying {get; }
        void Stop();
    }
}

namespace Lec2_Inheritance
{
    public interface ICanSwim : ICanStop
    {
        bool IsSwimming {get; }
        void Stop();
    }
}

/*Абстрактный класс - класс с абстрактными членами (не обязательно все)
абстрактный член - член который не имеет реализации в этом классе
У абстрактного класса нельзя создавать экземпляр его. Тип нельзя создавать то, у чего нет реализации. Значит нам 
не нужен публичный конструктор - нужен защищенный.
*/

namespace Lec2_Inheritance
{
    public abstract class Animal : IMortal, ICanStop
    {
        public bool IsAlive {get; private set; } = true;

        public virtual string Status => $"{GetType().Name} {GetHashCode()}: {(IsAlive ? "alive" : "dead")}";
        /*object - класс, от котого наследуются все классы по умолчанию. Корневой класс - самый дальний предок.
        Публичные методы:
        1. - virtual int GetHashCode() - возвращает хешкод объекта - связано с расположением в памяти
        2. - virtual bool Equals (object O) - позволяет сравнивать объекты класса - по умолчанию тру,
                                            если это один итот же объект
        3. - virtual string ToString() - возвращает полное наименование класса, включая пространство имени и борку
        4. - Type GetType() - возвращает тип*/

        public abstract bool Stop();
        protected bool Die()
        {
            if (IsAlive)
            {
                IsAlive = false;
                return true;
            }
            else
            {
                return false;
            }
        }
    }

    
}

/*
Полиморфизм -  это возможность использовать классы – потомки в контексте, который был предназначен для класса – 
предка
Ad-hoc полиморфизм (статический полиморфизм, раннее связывание)
Параметрический полиморфизм
Полиморфизм подтипов (динамический полиморфизм, позднее связывание) - ООП

*/